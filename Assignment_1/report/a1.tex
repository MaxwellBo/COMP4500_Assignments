\documentclass[11pt,a4paper]{article}

\usepackage{fullpage}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{verbatim}

\usepackage{graphicx}
\graphicspath{ {images/} }

\usepackage[colorlinks = true,
            linkcolor = blue,
            urlcolor  = blue,
            citecolor = blue,
            anchorcolor = blue]{hyperref}

\begin{document}

\title{COMP4500 \\ Assignment 1}
\author{Maxwell Bo (43926871)}
\date{September 17, 2018}
\maketitle

\subsection*{Question 1: Constructing SNI and directed graph}
\subsubsection*{(a) Creating your SNI}

My initial input number was $984392687152$. My resulting SNI was the same, $984392687152$.

\subsubsection*{(b) Graph $S$}

\includegraphics[width=5cm]{G-graph}
\newpage
\subsection*{Question 2: Strongly connected components}

\subsubsection*{(a) Step 1 of the SCC algorithm using $S$ as input}

To be nicer to my printer, I've substituted gray with yellow, and black with gray.

\includegraphics[width=2.2cm]{G-1}
\includegraphics[width=2.2cm]{G-2}
\includegraphics[width=2.2cm]{G-3}
\includegraphics[width=2.2cm]{G-4}
\includegraphics[width=2.2cm]{G-5}
\includegraphics[width=2.2cm]{G-6}
\includegraphics[width=2.2cm]{G-7}
\includegraphics[width=2.2cm]{G-8}
\includegraphics[width=2.2cm]{G-9}
\includegraphics[width=2.2cm]{G-10}
\includegraphics[width=2.2cm]{G-11}
\includegraphics[width=2.2cm]{G-12}
\includegraphics[width=2.2cm]{G-13}
\includegraphics[width=2.2cm]{G-14}
\includegraphics[width=2.2cm]{G-15}
\includegraphics[width=2.2cm]{G-16}
\includegraphics[width=2.2cm]{G-17}
\includegraphics[width=2.2cm]{G-18}
\includegraphics[width=2.2cm]{G-19}
\includegraphics[width=2.2cm]{G-20}

\subsubsection*{(b) Step 2 of the SCC algorithm - $S^T$}

\includegraphics[width=2.7cm]{GT-transpose}

\subsubsection*{(c) Step 3 and 4 of the SCC algorithm}

\includegraphics[width=2.7cm]{GT-trees}

The tree rooted with $1$ was constructed first, and the tree rooted with $0$ was constructed second.

\newpage

\subsection*{Question 3: Design and implement a solution}

\subsection*{Question 4: Worst-case complexity analysis}


\subsubsection*{(a) and (b) combined}

Rather than treating each $\mathcal{P}$ as a node, and each $\mathcal{D}$ as an edge in a graph, this algorithm treats each $\mathcal{D}$ as a node. 

A valid edge betwen two $\mathcal{D}$ constitutes a two element sub-path of a possible route from $P_s$ to $P_d$.

\begingroup
\fontsize{11pt}{11pt}\selectfont
\verbatiminput{pseudo.py} 
\endgroup

\subsubsection*{(b)}

The time complexity of Dijkstra's algorithm, $\Theta(\mathcal{D}^2)$, dominates, or is of the same class, as all other parts of our algorithm ($O(\mathcal{D})$, $O(\mathcal{D}^2)$, $O(\mathcal{D})$, $O(\mathcal{D})$), as well as providing a lower-bound.

Thus, the time complexity is $\Theta(\mathcal{D}^2)$ which describes both an asymptotic upper and lower bound on the worst case time complexity of this algorithm.

We assume that \texttt{HashSet} and \texttt{HashMap} never degenerate into $O(n)$ \texttt{put}s, \texttt{get}s, \texttt{add}s and \texttt{Iterator::next}s, and choose the $O(1)$ best case scenario. We use a Binary Heap in the implementation of Dijkstra's, with $O(\lg V)$ \texttt{Extract-Min}s and \texttt{Decrease-Key}s.

A $\mathcal{D}$ that describes a complete graph of valid delivery sequencing would exploit the worst-case complexity of this algorithm.

\end{document}